// Generated by CoffeeScript 1.7.1
var File, Folder, async, fs, getFileClass, log, moment, normalizePath, pathHelpers, processAttachement, sharing,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

async = require('async');

moment = require('moment');

File = require('../models/file');

Folder = require('../models/folder');

sharing = require('../helpers/sharing');

pathHelpers = require('../helpers/path');

log = require('printit')({
  prefix: 'files'
});

normalizePath = function(path) {
  if (path[0] !== '/') {
    path = "/" + path;
  }
  if (path === "/") {
    path = "";
  }
  return path;
};

processAttachement = function(req, res, next, download) {
  var contentHeader, file, stream;
  file = req.file;
  if (download) {
    contentHeader = "attachment; filename=" + file.name;
  } else {
    contentHeader = "inline; filename=" + file.name;
  }
  res.setHeader('Content-Disposition', contentHeader);
  stream = file.getBinary("file", (function(_this) {
    return function(err, resp, body) {
      if (err) {
        return next(err);
      }
    };
  })(this));
  stream.pipefilter = function(source, dest) {
    var XSSmimeTypes, _ref;
    XSSmimeTypes = ['text/html', 'image/svg+xml'];
    if (_ref = source.headers['content-type'], __indexOf.call(XSSmimeTypes, _ref) >= 0) {
      return dest.setHeader('content-type', 'text/plain');
    }
  };
  return stream.pipe(res);
};

getFileClass = function(file) {
  var fileClass;
  switch (file.type.split('/')[0]) {
    case 'image':
      fileClass = "image";
      break;
    case 'application':
      fileClass = "document";
      break;
    case 'text':
      fileClass = "document";
      break;
    case 'audio':
      fileClass = "music";
      break;
    case 'video':
      fileClass = "video";
      break;
    default:
      fileClass = "file";
  }
  return fileClass;
};

module.exports.fetch = function(req, res, next, id) {
  return File.request('all', {
    key: id
  }, function(err, file) {
    if (err || !file || file.length === 0) {
      if (err == null) {
        err = new Error('File not found');
        err.status = 404;
        err.template = {
          name: '404',
          params: {
            localization: require('../lib/localization_manager'),
            isPublic: req.url.indexOf('public') !== -1
          }
        };
      }
      return next(err);
    } else {
      req.file = file[0];
      return next();
    }
  });
};

module.exports.find = function(req, res) {
  return res.send(req.file);
};

module.exports.all = function(req, res, next) {
  return File.all(function(err, files) {
    if (err) {
      return next(err);
    } else {
      return res.send(files);
    }
  });
};

module.exports.create = function(req, res, next) {
  var fullPath;
  if (!req.body.name || req.body.name === "") {
    return next(new Error("Invalid arguments"));
  } else {
    req.body.path = normalizePath(req.body.path);
    fullPath = "" + req.body.path + "/" + req.body.name;
    return File.byFullPath({
      key: fullPath
    }, (function(_this) {
      return function(err, sameFiles) {
        var createFile, data, file, fileClass, now;
        if (sameFiles.length > 0) {
          return res.send({
            error: true,
            msg: "This file already exists"
          }, 400);
        } else {
          file = req.files["file"];
          now = moment().toISOString();
          fileClass = getFileClass(file);
          data = {
            name: req.body.name,
            path: req.body.path,
            creationDate: now,
            lastModification: now,
            mime: file.type,
            size: file.size,
            tags: [],
            "class": fileClass
          };
          createFile = function() {
            return File.createNewFile(data, file, (function(_this) {
              return function(err, newfile) {
                var who;
                who = req.guestEmail || 'owner';
                return sharing.notifyChanges(who, newfile, function(err) {
                  if (err) {
                    console.log(err);
                  }
                  return res.send(newfile, 200);
                });
              };
            })(this));
          };
          return Folder.byFullPath({
            key: data.path
          }, function(err, parents) {
            var parent;
            if (parents.length > 0) {
              parent = parents[0];
              data.tags = parent.tags;
              parent.lastModification = now;
              return parent.save(function(err) {
                if (err) {
                  return next(err);
                } else {
                  return createFile();
                }
              });
            } else {
              return createFile();
            }
          });
        }
      };
    })(this));
  }
};

module.exports.modify = function(req, res, next) {
  var body, file, fullPath, isPublic, newFullPath, newName, newPath, previousFullPath, previousName, previousPath, tags, _ref, _ref1;
  log.info("File modification of " + req.file.name + "...");
  file = req.file;
  body = req.body;
  if (body.tags && (Array.isArray(body.tags)) && ((_ref = file.tags) != null ? _ref.toString() : void 0) !== ((_ref1 = body.tags) != null ? _ref1.toString() : void 0)) {
    tags = body.tags;
    tags = tags.filter(function(tag) {
      return typeof tag === 'string';
    });
    return file.updateAttributes({
      tags: tags
    }, (function(_this) {
      return function(err) {
        if (err) {
          return next(new Error("Cannot change tags: " + err));
        } else {
          log.info("Tags changed for " + file.name + ": " + tags);
          return res.send({
            success: 'Tags successfully changed'
          }, 200);
        }
      };
    })(this));
  } else if ((!body.name || body.name === "") && (body.path == null)) {
    log.debug(body);
    log.info("No arguments, no modification performed for " + req.file.name);
    return next(new Error("Invalid arguments, name should be specified."));
  } else {
    previousName = file.name;
    newName = body.name != null ? body.name : previousName;
    previousPath = file.path;
    if (req.body.path != null) {
      body.path = normalizePath(body.path);
    }
    newPath = body.path != null ? body.path : previousPath;
    isPublic = body["public"];
    newFullPath = "" + newPath + "/" + newName;
    previousFullPath = "" + previousPath + "/" + previousName;
    fullPath = "" + req.body.path + "/" + req.body.name;
    return File.byFullPath({
      key: fullPath
    }, (function(_this) {
      return function(err, sameFiles) {
        var data, modificationSuccess;
        if (err) {
          return next(err);
        }
        modificationSuccess = function(err) {
          if (err) {
            log.raw(err);
          }
          log.info(("Filechanged from " + previousFullPath + " ") + ("to " + newFullPath));
          return res.send({
            success: 'File successfully modified'
          });
        };
        if (sameFiles.length > 0) {
          log.info("No modification: Name " + newName + " already exists.");
          return res.send({
            error: true,
            msg: "The name is already in use."
          }, 400);
        } else {
          data = {
            name: newName,
            path: newPath,
            "public": isPublic,
            lastModification: moment().toISOString()
          };
          if (body.clearance) {
            data.clearance = body.clearance;
          }
          return file.updateAttributes(data, function(err) {
            if (err) {
              return next(new Error('Cannot modify file'));
            } else {
              return file.updateParentModifDate(function(err) {
                if (err) {
                  log.raw(err);
                }
                return file.index(["name"], modificationSuccess);
              });
            }
          });
        }
      };
    })(this));
  }
};

module.exports.destroy = function(req, res, next) {
  var file;
  file = req.file;
  return file.removeBinary("file", (function(_this) {
    return function(err, resp, body) {
      if (err && err.toString('utf8').indexOf('not found') === -1) {
        log.error("Cannot Remove binary for " + file.id);
        return next(err);
      } else {
        return file.destroy(function(err) {
          if (err) {
            log.error("Cannot destroy document " + file.id);
            return next(err);
          } else {
            return file.updateParentModifDate(function(err) {
              if (err) {
                log.raw(err);
              }
              return res.send({
                success: 'File successfully deleted'
              });
            });
          }
        });
      }
    };
  })(this));
};

module.exports.getAttachment = function(req, res, next) {
  return processAttachement(req, res, next, false);
};

module.exports.downloadAttachment = function(req, res, next) {
  return processAttachement(req, res, next, true);
};

module.exports.search = function(req, res, next) {
  var parts, query, sendResults, tag;
  sendResults = function(err, files) {
    if (err) {
      return next(err);
    } else {
      return res.send(files);
    }
  };
  query = req.body.id;
  query = query.trim();
  if (query.indexOf('tag:') !== -1) {
    parts = query.split();
    parts = parts.filter(function(tag) {
      return tag.indexOf('tag:' !== -1);
    });
    tag = parts[0].split('tag:')[1];
    return File.request('byTag', {
      key: tag
    }, sendResults);
  } else {
    return File.search("*" + query + "*", sendResults);
  }
};
